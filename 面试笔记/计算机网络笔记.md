# 计算机网络复习

[TOC]

# 一、计算机网络体系架构

1. 计算机网络的概念：计算机网络就是一些**互联的**、**自治的**计算机系统的集合
2. 两大交换网络：
   - 电路交换: 每次会话预留沿其路径（线路）所需的独占资源
   - 分组交换: 数据以离散的数据块通过网络来发送
     - 数据报网络: TCP/IP：分组目的地址决定下一跳， 会话期间路由可以改变， 数据报网络既可以提供面向连接的服务也可以提供无连接的服务。
     - 虚电路网络: X.25,FR,ATM：每个分组有1个标签  (虚电路号,virtual circuit ID), 标签决定下1跳，连接建立时确定固定的路径, 并且将保持于整个会话期间。虚电路网络一定是面向连接的。 

3. **协议的三要素**：
   - 语法：数据与控制信息的结构或格式
   - 语义：对构成协议元素的含义的解释
   - 同步：规定了事件的执行顺序

4. **分组延迟的4种类型**：1. 节点处理时延 2. 排队时延 3. 传输时延（R=链路带宽，L=分组长度，发送分组比特流的时间 = L/R） 4. 传播时延（d = 物理链路的长度，s = 介质的信号传播速度，传播延迟 = d/s）
   - 传输时延又称发送时延，是主机或路由器发送数据帧所需要的时间
   - 为什么没有接收时延：事实上接受时延包含在发送和传播时延中，当这两个时延结束是接受时延就结束了

5. 往返时间（RTT）：从发送方发送数据开始，到发送方收到来自接收方的确认消息总共经历的时间
6. 带宽：表示在数据链路上每秒传输的比特数，一般单位是Mbit/s
7. 吞吐量：单位时间内整个网络传输数据的速率或分组数，单位：bps或data packets per second
8. P个分组通过由N条速率均为R的链路组成的路径（意味着源和目的地之间有N-1台路由器），的端到端传输时延为（N + P - 1) \* L / R
9. 描述磁盘时一般用KB，K = 2^10，描述带宽或者通信传输率时一般用kbit/s，k = 10^3^
10. 多数分组交换机在链路的输入端使用**存储转发传输**：存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特前必须接收到整个分组。

# 二、应用层

## DNS

1. 域名结构：根，顶级域名，二级域名，三级域名……

2. 域名服务器结构：

   - 根域名服务器
   - 顶级域名服务器（管理在其下注册的所有二级域名）
   - 权威域名服务器（管理三级及以下域名）
   - 本地域名服务器（主机发出DNS查询请求时，先将请求报文发送给本地域名服务器，也起着缓存的作用）

3. 主机向本地域名服务器的查询是采用递归查询，而本地域名服务器向根域名服务器查询采用的是迭代查询

4. DNS存储资源记录（RR Resource Records）,RR格式（name， value，type，ttl）

   - Type = A (Adress)

     name = 主机名

     value = IP地址

   - Type = CNAME(canonical)

     ​	name = 主机别名

     ​	value = 真实的规范主机名

   - Type  = NS(name server)

     name  = 域名（如foo.com）

     value = 该域权威名字服务器的主机名

   - Type = MX（mail exchange）

     name = 邮件服务器的主机名

     value = 邮件服务器的真实规范主机名

## http

### 请求报文

GET /somedir/page.html HTTP/1.1 

Host: www.someschool.edu  //虽然存在TCP连接，但是报文中仍然需要主机信息，这是web代理高速缓存要求的

User-agent: Mozilla/4.0 //该代理类型的对象版本，即浏览器类型和版本

Connection: Close  //不使用持久连接

Accept: text/html 浏览器可以接受服务器回发的类型为 text/html。

Accept-language:zh-cn //中文版本

Accept-Encoding:..

referer:www.baidu.com

cookie:...

cache-controll:缓存的使用方式

if modify since:...

![image-20201219165054759](C:\Users\etan\AppData\Roaming\Typora\typora-user-images\image-20201219165054759.png)

### 响应报文

HTTP/1.1 200 OK （状态行 协议版本+状态码+状态信息）

Connection：close

Date: Sat, 06 Aug 2011 12:00:15 GMT // 服务器从它的文件系统中检索到该对象，将该对象插入响应报文并发送的时间

Server: Apache/1.3.0 (Unix) 

cookie:...

Last-Modified: Thu, 22 Jun 2011 …... 

Content-Length: 6821 

Content-Type: text/html

cache-controll:缓存的使用方式

### HTTP常用方法

GET

POST：提交表单时常用。提交表单时也可用GET。

> 如果有大数据要post，可以在请求报文头部中加入"Expect":"100-continue"，表示用100-continue协议，只发送头部给服务器。对于服务端：正确情况下，收到请求后，返回100或错误码；如果在发送100-continue前收到了POST数据（客户端提前发送POST数据），则不发送100响应码(略去)。对于客户端，收到状态码为100的响应报文后正常传输post报文。所以post报文可以以两次传输的方式完成。目的是如果请求报文头部有问题，可以省去传输大报文体的时间。
>
> 如果没有POST数据，不能使用100-continue协议，因为这会让服务端造成误解

HEAD：服务器收到请求时，用HTTP报文进行响应，但不返回请求对象

PUT：文件在实体主体中被上载到URL字段指定的路径，常用于上传对象到指定的Web服务器上指定的目录

DELETE：删除URL字段指定的Web服务器上的文件

#### GET和POST的比较

| 分类     | GET                               | POST                                                         |
| -------- | --------------------------------- | ------------------------------------------------------------ |
| 缓存     | 可缓存                            | 不可缓存                                                     |
| 书签     | 可收藏为书签                      | 不可收藏为书签                                               |
| 参数位置 | 在url中                           | 在请求报文体中                                               |
| 编码类型 | application/x-www-form-urlencoded | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 传输次数 | 一次                              | 可以用100-continue进行两次传输                               |

### HTTP常见状态码

> 含义参考资料：https://blog.csdn.net/MeiLuan_yahoho/article/details/88622409

| 状态码 | 短语                       | 含义                                                         |
| ------ | -------------------------- | ------------------------------------------------------------ |
| 200    | OK                         | 成功响应                                                     |
| 301    | Moved Permanently          | 请求的对象已经被永久转移了，新的 URL 定义在响应报文的Location 首部行，客户将自动获取新的 URL。比如，我们访问 **http**://www.baidu.com 会跳转到 **https**://www.baidu.com；404跳转到首页等 |
| 302    | Found                      | 与301类似，但是用作临时跳转，比如未登陆的用户访问用户中心重定向到登录页面。 |
| 400    | Bad Request                | 一个通用的差错代码，标识该请求不能被服务器理解，表示请求报文中存在语法错误 |
| 401    | Unauthorized               | 未认证，缺乏相关权限。                                       |
| 402    | Payment Required           | 保留，将来使用                                               |
| 403    | Forbidden                  | 服务器理解客户端的请求，但是拒绝执行，表明对请求资源的访问被服务器拒绝了。比如用户ip被屏蔽，或者用户访问内网用户才能访问的内容 |
| 404    | Not Found                  | 被请求的文档不在服务器上，有可能因为请求 URL 出错。          |
| 405    | Method Not Allowed         | 客户端中请求的方法被禁止，例如限制 POST 方式但使用了 GET 访问。 |
| 500    | Internal Server Error      | 服务器内部错误，无法完成请求。                               |
| 501    | Not Implemented            | 服务器不支持请求的功能，无法完成请求。                       |
| 502    | Bad Gateway                | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应。 |
| 503    | Service Unavailable        | 由于超载或系统维护，服务器暂时的无法处理客户端的请求。       |
| 504    | Gateway Timeout            | 充当网关或代理的服务器，未及时从远端服务器获取请求。         |
| 505    | HTTP Version Not Supported | 服务器不支持请求报文使用的 HTTP 协议版本。                   |

### 常用HTTP头部

#### 请求头部

**1.Accept**

- **Accept: text/html** 浏览器可以接受服务器回发的类型为 text/html。
- **Accept: \*/\***  代表浏览器可以处理所有类型,(一般浏览器发给服务器都是发这个)。

**2.Accept-Encoding**

- **Accept-Encoding: gzip, deflate** 浏览器申明自己接收的编码方法，通常指定压缩方法，是否支持压缩，支持什么压缩方法（gzip，deflate），（注意：这不是只字符编码）。

**3.Accept-Language**

- **Accept-Language:zh-CN,zh;q=0.9** 浏览器申明自己接收的语言。

**4.Connection**

- **Connection: keep-alive** 当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
-  **Connection: close** 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。

**5.Host（发送请求时，该报头域是必需的）**

- **Host:www.baidu.com** 请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的。

**6.Referer**

- **Referer:https://www.baidu.com/?tn=62095104_8_oem_dg** 当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。

**7.User-Agent**

- **User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36** 告诉HTTP服务器， 客户端使用的操作系统和浏览器的名称和版本。

**8.Cache-Control**

- **Cache-Control:private** 默认为private 响应只能够作为私有的缓存，不能再用户间共享
- **Cache-Control:public**响应会被缓存，并且在多用户间共享。正常情况, 如果要求HTTP认证,响应会自动设置为 private.
- **Cache-Control:must-revalidate** 响应在特定条件下会被重用，以满足接下来的请求，但是它必须到服务器端去验证它是不是仍然是最新的。
- **Cache-Control:no-cache** 响应不会被缓存,而是实时向服务器端请求资源。
- **Cache-Control:max-age=10** 设置缓存最大的有效时间，但是这个参数定义的是时间大小（比如：60）而不是确定的时间点。单位是[秒 seconds]。
- **`Cache-Control:no-store `**在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里，这也是基于安全考虑的某些敏感的响应才会使用这个。

**9.Cookie**

Cookie是用来存储一些用户信息以便让服务器辨别用户身份的（大多数需要登录的网站上面会比较常见），比如cookie会存储一些用户的用户名和密码，当用户登录后就会在客户端产生一个cookie来存储相关信息，这样浏览器通过读取cookie的信息去服务器上验证并通过后会判定你是合法用户，从而允许查看相应网页。当然cookie里面的数据不仅仅是上述范围，还有很多信息可以存储是cookie里面，比如sessionid等。

**10.Range（用于断点续传）**

- **Range:bytes=0-5** 指定第一个字节的位置和最后一个字节的位置。用于告诉服务器自己想取对象的哪部分。

#### 响应头部

**1.Cache-Control（对应请求中的Cache-Control）**

- **Cache-Control:private** 默认为private  响应只能够作为私有的缓存，不能再用户间共享
- **Cache-Control:public** 浏览器和缓存服务器都可以缓存页面信息。
- **Cache-Control:must-revalidate**  对于客户机的每次请求，代理服务器必须想服务器验证缓存是否过时。
- **Cache-Control:no-cache**  浏览器和缓存服务器都不应该缓存页面信息。
- **Cache-Control:max-age=10** 是通知浏览器10秒之内不要烦我，自己从缓冲区中刷新。
- **Cache-Control:no-store** 请求和响应的信息都不应该被存储在对方的磁盘系统中。

**2.Content-Type**

- **Content-Type：text/html;charset=UTF-8** 告诉客户端，资源文件的类型，还有字符编码，客户端通过utf-8对资源进行解码，然后对资源进行html解析。通常我们会看到有些网站是乱码的，往往就是服务器端没有返回正确的编码。

**3.Content-Encoding**

- **Content-Encoding:gzip** 告诉客户端，服务端发送的资源是采用gzip编码的，客户端看到这个信息后，应该采用gzip对资源进行解码。

**4.Date**

- **Date: Tue, 03 Apr 2018 03:52:28 GMT** 这个是服务端发送资源时的服务器时间，GMT是格林尼治所在地的标准时间。http协议中发送的时间都是GMT的，这主要是解决在互联网上，不同时区在相互请求资源的时候，时间混乱问题。

**5.Server**

- **Server：Tengine/1.4.6** 这个是服务器和相对应的版本，只是告诉客户端服务器信息**。**

**6.Transfer-Encoding**

- **Transfer-Encoding：chunked** 这个响应头告诉客户端，服务器发送的资源的方式是分块发送的。一般分块发送的资源都是服务器动态生成的，在发送时还不知道发送资源的大小，所以采用分块发送，每一块都是独立的，独立的块都能标示自己的长度，最后一块是0长度的，当客户端读到这个0长度的块时，就可以确定资源已经传输完了。

**7.Expires**

- **Expires:Sun, 1 Jan 2000 01:00:00 GMT** 这个响应头也是跟缓存有关的，告诉客户端在这个时间前，可以直接访问缓存副本，很显然这个值会存在问题，因为客户端和服务器的时间不一定会都是相同的，如果时间不同就会导致问题。所以这个响应头是没有Cache-Control：max-age=*这个响应头准确的，因为max-age=date中的date是个相对时间，不仅更好理解，也更准确。

**8.Last-Modified**

- **Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT** 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示)

**9.Connection**

- **Connection：keep-alive** 这个字段作为回应客户端的Connection：keep-alive，告诉客户端服务器的tcp连接也是一个长连接，客户端可以继续使用这个tcp连接发送http请求。

**10.Etag**

- **ETag: "737060cd8c284d8af7ad3082f209582d"** 就是一个对象（比如URL）的标志值，就一个对象而言，比如一个html文件，如果被修改了，其Etag也会别修改，所以，ETag的作用跟Last-Modified的作用差不多，主要供WEB服务器判断一个对象是否改变了。比如前一次请求某个html文件时，获得了其 ETag，当这次又请求这个文件时，浏览器就会把先前获得ETag值发送给WEB服务器，然后WEB服务器会把这个ETag跟该文件的当前ETag进行对比，然后就知道这个文件有没有改变了。

**11.Refresh**

- **Refresh: 5; url=http://baidu.com** 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。

**12.Access-Control-Allow-Origin** 

- **Access-Control-Allow-Origin: \***  *号代表所有网站可以跨域资源共享，如果当前字段为*那么Access-Control-Allow-Credentials就不能为true
- **Access-Control-Allow-Origin: www.baidu.com** 指定哪些网站可以跨域资源共享

**13.Access-Control-Allow-Methods**

- **Access-Control-Allow-Methods：GET,POST,PUT,DELETE** 允许哪些方法来访问

**14.Access-Control-Allow-Credentials**

- **Access-Control-Allow-Credentials: true** 是否允许发送cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。如果access-control-allow-origin为*，当前字段就不能为true

**15.Content-Range**

- **Content-Range: bytes 0-5/7877** 指定整个实体中的一部分的插入位置，他也指示了整个实体的长度。在服务器向客户返回一个部分响应，它必须描述响应覆盖的范围和整个实体长度。

### 两种HTTP连接

- 非持久HTTP连接：每个TCP连接上只传送一个对象，下载多个对象需要建立多个TCP连接

- 持久HTTP连接：一个TCP连接上可以传送多个对象

### 条件GET方法

目的:证实Web缓存器中的对象是否为最新

缓存器：在请求报文中包含旧对象最后修改时间 

If-modified-since: \<date\>

服务器: 如果对象是最新的则响应报文中不包含对象，如果服务器网页已经更新就会发送把客户端的请求当作一个普通的Get请求发送相应报文: 

HTTP/1.0 304 Not Modified

HTTP/1.0 200 OK

用户发起http请求时应该首先与web缓存器建立连接，如果web缓存器中有请求对象，则让其发起条件GET，如果无，则让其代向目标服务器发起请求。

### Cookie和Session

> 参考资料：https://zhuanlan.zhihu.com/p/27669892

Cookie是允许站点对用户进行追踪的**客户端会话技术**。一般用于验证用户身份。**存储在客户浏览器中**。由服务器在响应报文首部行设置：

```
1. 请求报文（没有Cookie 信息的状态）
GET /reader/ HTTP/1.1
Host: hackr.jp
*首部字段内没有Cookie的相关信息

2. 响应报文（服务器端生成Cookie 信息）
HTTP/1.1 200 OK
Date: Thu, 12 Jul 2012 07:12:20 GMT
Server: Apache
＜Set-Cookie: sid=1342077140226724; path=/; expires=Wed,10-Oct-12 07:12:20 GMT＞
Content-Type: text/plain; charset=UTF-8

3. 请求报文（自动发送保存着的Cookie 信息）
GET /image/ HTTP/1.1
Host: hackr.jp
Cookie: sid=1342077140226724
```

Session 对象存储特定用户会话所需的**属性**及**配置信息**。当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。当用户请求来自应用程序的 Web 页时，如果该用户还没有会话，则 Web 服务器将自动创建一个 Session 对象。当会话过期或被放弃后，服务器将终止该会话。Session 对象最常见的一个用法就是存储用户的首选项。Session**储存在服务器中**。

一般会使用Cookie 来管理Session（会话）。

> - 步骤一：客户端把用户ID 和密码等登录信息放入报文的实体部分，通常是以POST 方法把请求发送给服务器。而这时，会使用HTTPS 通信来进行HTML 表单画面的显示和用户输入数据的发送。
> - 步骤二：服务器会发放用以识别用户的Session ID。通过验证从客户端发送过来的登录信息进行身份认证，然后把用户的认证状态与Session ID 绑定后记录在服务器端。
>   向客户端返回响应时，会在首部字段Set-Cookie 内写入**Session ID**（如PHPSESSID=028a8c…）。
>   你可以把Session ID 想象成一种用以区分不同用户的等位号。然而，如果Session ID 被第三方盗走，对方就可以伪装成你的身份进行恶意操作了。因此必须防止Session ID 被盗，或被猜出。为了做到这点，Session ID 应使用难以推测的字符串，且服务器端也需要进行有效期的管理，保证其安全性。
>   另外，为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie 内加上httponly 属性。
> - 步骤三：客户端接收到从服务器端发来的Session ID 后，会将其作为Cookie 保存在本地。下次向服务器发送请求时，浏览器会自动发送Cookie，所以Session ID 也随之发送到服务器。服务器端可通过验证接收到的Session ID 识别用户和其认证状态。

### 输入一个url发生的事情

1. 分析 url
   判断输入的 url 是否合法，如果不合法浏览器会使用默认的搜索引擎进行搜索。如果输入的是一个域名，默认会加上一个 http 前缀。
2. DNS 查询
   检查浏览器的 DNS 缓存，检查本地 hosts 文件的缓存，如果没有会向本地 DNS 服务器发送请求。主机向本地 DNS 服务器发起请求是递归查询，如果找到则返回，否则本地DNS服务器会向根 DNS 服务器，顶级域名服务器等发起迭代查询。
3. web缓存服务器
   条件GET，TCP/IP结构往下说……
4. 处理请求
   服务器收到 HTTP 请求报文后进行响应，主进程进行监听，创建子进程处理，先判断是否是重定向，如果是重定向则返回重定向地址。如果是静态资源则直接返回，否则在代码层面处理返回结果，最后返回 HTTP 响应报文。

5. 接收响应
   浏览器收到 HTTP 响应报文后进行解析，首先查看响应报文在状态行的状态码，根据不同的状态码做不同的事，解析 HTML、CSS、JS 等文件。构建 DOM 树，渲染树，重绘，将像素发送 GPU 进行渲染，最后将渲染结果返回给用户并进行缓存。

6. TCP 断开连接
   通过 TCP 的四次挥手断开连接。

### HTTPS

#### HTTP存在的问题

**HTTP 没有报文加密**，无法保证通信内容不被窃听，攻击者可以截取客户发送的数据并得到他的信息。

**HTTP 没有报文完整性验证**，无法确保通信内容在传输过程中不被改变，攻击者可以篡改客户通信内容。

**HTTP 没有身份鉴别**，无法让通信双方确认对方的身份，攻击者可以伪装成客户或者服务器。

#### TLS原理

客户会给服务器发送自己支持的密码套件，服务器会从中选择一个来作为本次会话的算法。服务器会发送自己包含公钥的证书给客户，客户会生成一个预主密钥，用服务器公钥加密发送给服务器，然后双方会利用预主密钥生成一个主密钥，将主密钥切分可以获得本次通话的**对称加密密钥**以及**消息认证密钥**，对称加密密钥可以解决报文保密性和完整性的问题，消息认证密钥可以验证消息的发送方是否真的是对方，可以解决用户认证的问题。

<img src="../../../E/typora/Pictures/image-20210126204926644.png" alt="image-20210126204926644" style="zoom:67%;" />

<img src="../../../E/typora/Pictures/image-20210126204955974.png" alt="image-20210126204955974" style="zoom:67%;" />

<img src="../../../E/typora/Pictures/image-20210126205014099.png" alt="image-20210126205014099" style="zoom:67%;" />



# 三、传输层

1. 传输层的功能
   - 提供应用进程之间的逻辑通信（网络层提供主机之间的逻辑通信）
   - 差错检测
   - 提供无连接或面向连接的服务
     - 面向连接的服务还提供（1）连接管理（2）流量控制和拥塞控制
   - 复用和分用
2. TCP使用了诸如确认、滑动窗口、计时器等机制，因而可以检测出有差错的报文、重复和失序的报文
3.  熟知端口：0-1023 登记端口：1024-49151（需要在INAN互联网号码分配局登记） 客户端短暂端口49152-65535

4. 套接字唯一地标识了网络中某台主机上的某个应用进程

## UDP

UDP 对应用层交下来的报文，既不合并，也不拆分。应用程序必须选择合适大小的报文。

### UDP报文

UDP报文含有8字节首部

![image-20201223164326847](C:\Users\etan\AppData\Roaming\Typora\typora-user-images\image-20201223164326847.png)

### Internet校验和

![image-20201223164414374](C:\Users\etan\AppData\Roaming\Typora\typora-user-images\image-20201223164414374.png)

### UDP校验

校验范围：伪首部、UDP数据包的首部和数据

在计算校验和时，要在UDP数据报前临时加上**12B**的伪首部， **2B**一组运算

伪首部组成：源IP地址字段（4B），目的IP字段（4B），全0字段（1B），协议字段，UDP固定为17（1B），UDP长度字段，首部加数据长度之和，同首部的第三个字段（2B），如果UDP报文长度为奇数则需要在末尾补充1个全0字节

<img src="C:\Users\etan\AppData\Roaming\Typora\typora-user-images\image-20201223165659273.png" alt="image-20201223165659273" style="zoom: 25%;" />

接收方验证时，二进制反码运算求和后结果应该为全1

## TCP

### TCP报文段（segment）

1. TCP提供的服务
   - 面向连接的可靠数据传输
   - 差错检测
   - 流量控制
   - 拥塞控制
2. TCP报文段占20字节，数据偏移指示了以**4B**为单位的**TCP首部长度**
3. 窗口字段：明确指出了现在允许多方发送的数据量，例如，设确认号是701，窗口字段是1000，这就表明从701号开始算起，发送此报文的一方还有接收1000B数据的缓存空间。
4. TCP计算校验和同UDP计算，要加上伪首部，协议字段的17改为6即可
5. 紧急指针，指出紧急数据最后一个字节的序号
6. 填充字段，使得报文首部长度为4B的整数倍
7. 个人注释：TCP报文首部中并无报文长度，原因是因为报文长度可以通过IP报文的信息计算出。UDP首部有报文长度的原因可能是为了4B对齐。

![image-20201223171350875](C:\Users\etan\AppData\Roaming\Typora\typora-user-images\image-20201223171350875.png)

7. TCP有MSS，Maximum Segment Size，（最大报文段长，指的是报文段里**应用层数据的最大长度**，受限于最大链路层帧长度MTU），流水线，全双工。TCP报文段的长度大于MSS时，要进行分段传输。

### TCP三次握手

1. TCP规定，SYN报文不能携带数据，但是要消耗一个序号

<img src="C:\Users\etan\AppData\Roaming\Typora\typora-user-images\image-20201223173413150.png" alt="image-20201223173413150" style="zoom: 25%;" />

#### 为什么不是两次握手

> 参考资料：https://blog.csdn.net/lengxiao1993/article/details/82771768

根本原因：

- 为了实现可靠数据传输， TCP 协议的通信双方， 都必须**维护一个序列号**， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方**相互告知序列号起始值**， 并确认对方已经收到了序列号起始值的必经步骤
- 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认

次要原因：

- 三次握手也是防止失效连接突然到达导致**脏连接**，网络报文的生存时间往往会超过 TCP 请求超时时间，A 的某个超时连接请求可能会在双方释放连接之后到达 B，B 会误以为是 A 创建了新的连接请求，然后发送确认报文创建连接。因为 A 机器的状态不是 SYN_SENT，所以直接丢弃了 B 的确认数据。如果是两次握手，连接已经建立了，**服务器资源被白白浪费**。如果是三次握手，B 由于长时间没有收到确认信息，最终超时导致创建连接失败，因此不会出现脏连接。

### TCP四次分手

> 参考资料：https://segmentfault.com/a/1190000020610336

1. 一方发送FIN后它就无法发送数据，但是对方还是可以发送数据的

<img src="C:\Users\etan\AppData\Roaming\Typora\typora-user-images\image-20201223174349050.png" alt="image-20201223174349050" style="zoom:25%;" />

#### 为什么需要四次挥手

因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中**ACK报文是用来应答的，SYN报文是用来同步的**。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。

#### 等待2MSL的原因

>  MSL为Maximum Segment Life，最长报文段寿命。

确保被发起关闭方进入正常的关闭状态。如果A不等待2MSL，如果返回的最后的确认报文丢失，那么A收到B重传的FIN报文时A已经关闭，不可能再进行重传。那么B不能进入正常的关闭状态。

另外，可以防止**已失效的连接请求报文段**出现在新连接中，客户端在发送完最后一个ACK报文段后，再经过2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。

### 流量控制

流量控制就是要控制发送方发送数据的速率，使接收方来得及接收。常见的有两种方式：

- 停止-等待流量控制
- 滑动窗口流量控制

#### 停止-等待流量控制

工作原理就是发送方发出一帧，然后等待应答信号达到再发送下一帧。接收方每收到一帧后，返回一个应答信号，表示可以可以接收下一帧，如果接收方不返回应答，则发送方必须一直等待。

#### 滑动窗口流量控制

发送方：维持了一组连续的允许发送的帧的序号，称为发送窗口。

接收方：维持了一组连续的允许接收的帧的序号，称为接收窗口

发送和接收窗口的序号的上下界和大小不一定一样。



对于TCP会话的发送方，任何时候在其**发送缓存**内的数据都可以分为4类，“已经发送并得到对端ACK的”，“已经发送但还未收到对端ACK的”，“未发送但对端允许发送的”，“未发送且对端不允许发送”。**“已经发送但还未收到对端ACK的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口（中间两部分）**。

![img](../../../E/typora/Pictures/110030_fP30_1469576.jpg)

当收到接收方新的ACK对于发送窗口中后续字节的确认是，窗口滑动，滑动原理如下图。

![img](../../../E/typora/Pictures/110101_XiAd_1469576.jpg)

对于TCP的接收方，在某一时刻在它的**接收缓存**内存在3种。“已接收”，“未接收准备接收”，“未接收并未准备接收”（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。**其中“未接收准备接收”称之为接收窗口**（rwnd）。**按序到达还没有被交付给主机的帧被放在“已接收”的部分，而不是在接收窗口里面。**

<img src="../../../E/typora/Pictures/110345_b1h1_1469576.jpg" alt="img" style="zoom: 50%;" />

### 可靠传输机制

可靠数据传输就是说发送方发送什么，接收方就收到什么，一般来说，使用**确认**和**超时重传**两种机制共同完成

超时重传是指发送方在发送一个数据帧时设置一个超时计时器，如果在规定时间内没有收到该帧的确认，就重新发送该数据帧。超时的原因有：

- 当接收方检测到出错帧时，接收方直接丢弃该帧，而不返回确认
- 该帧在传输过程中丢失
- 网络拥塞



可靠传输机制包括：

- 停止-等待协议：发送窗口大小 =1，接收窗口大小=1

- 后退N帧协议：发送窗口大小>1，接收窗口大小=1，发送窗口大小满足1< W~T~<=2^n^-1， n为编号比特数

- 选择重传协议：发送窗口大小>1，接收窗口大小>1，发送窗口大小满足1< W~T~<=2^n-1^

  (大小约束都是为了发送接收窗口大小和不超过2^n^，避免接收端向前移动后，新接收窗口与旧发送窗口重叠)



后退N帧协议（GBN）：发送方发送完一个数据帧后，可以不等确认帧，再发送若干个数据帧。如果这时收到了接收方的确认帧，那么还可以接着发送数据帧。如果某个帧出错了，接收方只能简单地丢弃该帧以及其后所有的后续帧。发送方超时后需要重发该出错帧以及后续的所有帧。支持累积确认。



选择重传协议（SR）：若一帧出错，其后续帧先存入接受方的缓冲区中，同时要求发送方重传出错帧，一旦接收到重传帧后，就和原先存在缓冲区的其余帧一起按正确的顺序送至主机。一般发送窗口大小等于接收窗口大小。**选择重传不支持累积确认。**

### TCP可靠数据传输

1. TCP采用累积确认，TCP是GBN和SR的结合体。

2. TCP**每发送一个报文段就对这个报文段设置一次重传计时器**，计时器超时，则重传**此报文段**。使用快速重传机制

   > 举个重传的例子：
   >
   > 1. Server 发送80个字节 Part1，seq = 1 
   >
   > 2. Server 发送120个字节Part2，Seq = 81
   >
   > 3. Server发送160个字节Part3，Seq = 201，此包由于其他原因丢失
   >
   > 4. Client收到前2个报文段，并发送ACK = 201
   >
   > 5. Server发送140个字节Part4， Seq = 361
   >
   > 7. Server收到Client对于**前两个报文段的ACK，将2个报文从窗口中移除**，窗口有200个字节的余量
   >
   > 8. 报文3的重传定时器到期，没有收到ACK，进行重传
   >
   > 9. 这个时候Client已经收到报文4，**存放在缓冲区中，也不会发送ACK【累计通知，发送ACK就表示3也收到了】**，等待报文3，报文3收到之后，一块对3,4进行确认
   >
   > 10. Server收到确认之后，将报文3,4移除窗口，所有数据发送完成

3. 快速重传：**如果发送方连续收到3次dup ACK，发送方就认为这个seq的包丢失了，立刻进行重传**，这样如果接收端回复及时的话，基本就是在重传定时器到期之前，提高了重传的效率。

   > 在传输过程中会出现out-of-order的现象，但是在滑动窗口中会有严格的顺序控制，假设有4，5，6三个待接收的数据包，先收到了5,6，协议栈是不会回复对5,6包的确认，而是根据TCP协议的规定，**当接收方收到乱序片段时，需要重复发送ACK**, 在这个地方会发送报文4 seq的ACK，表明需要报文4没有被接收到，如果此后收到的是报文7，那么仍然要回报文4 seq的ACK，如果连续发送3个 dup ACK，接收端认为这个片段已经丢失，进行快速重传。

4. TCP把数据看成一个无结构的、有序的字节流，**序号建立在传送的字节流上，而不是建立在传送的报文段的序列之上**。**一个报文段的序号是该报文段的首字节的字节流编号**。

5. TCP给每一个**连接**设置一个**持续计时器**，只要TCP连接的一方收到对方的零窗口通知，就启动持续计时器。若设置的时间到期，就发送一个零窗口探测报文段（仅携带1B）的数据，而对方就在确认这个探测报文段时给出了现在的窗口值。若窗口仍然是零，则发送方重新设置持续计时器。若不是零，则死锁的僵局就可以打破。

6. 除此之外，TCP 还设有一个**保活计时器**，用于解决客户端主机故障的问题，服务器每收到一次客户的数据就重新设置保活计时器，时间为 2 小时。如果 2 小时内没有收到就间隔 75 秒发送一次探测报文，连续 10 次都没有响应后就关闭连接。

#### TCP重传计时器设置自适应算法

> 大多数TCP的实现仅在某一时刻做一次SampleRTT测量，而不是为每个发送的报文段测量一个SampleRTT。且绝不为重传的报文段计算SampleRTT。
>
> 样本RTT均值：EstimatedRTT = (1- α)*EstimatedRTT + α*SampleRTT
>
> 典型α设置为0.125
>
> 安全余量：DevRTT = (1-β)*DevRTT +β*| SampleRTT-EstimatedRTT |
>
> 典型β设置为0.25
>
> 设置超时时间间隔:TimeoutInterval = EstimatedRTT + 4*DevRTT
>
> 超时后TimeoutInterval 加倍，以免继续超时，只要收到报文段并更新EstimatedRTT就使用上述公式再次计算TimeoutInterval。初始时TimeoutInterval设置为1秒。

### TCP拥塞控制

接收窗口（rwnd）：**接收端**根据其目前接受缓存大小所许诺的最新的窗口值，反映了接收端的容量。

拥塞窗口（cwnd）：**发送端**根据自己估计的网络拥塞程度而设置的窗口值，反映了网络的当前容量。

发送端**发送窗口**的上限值应当取两者中的较小值。接受方如果总是有足够大的缓存空间，那么发送窗口可以等同为拥塞窗口大小

#### 慢启动

1. 在主机刚开始发送报文段时，将cwnd设置为1，即一个最大报文段长度MSS的值
2. 每收到一个对**新报文段**的确认后，拥塞窗口加一

所以慢启动阶段拥塞窗口是在一个RTT时间单位内指数增加的。 cwnd每回合翻倍时，触碰到ssthresh时就在此回合停在ssthresh的数据大小的位置。

#### 拥塞避免

为防止拥塞窗口cwnd的增长引起网络阻塞，还需要一个慢启动门限ssthresh：

- 当cwnd < ssthresh时，使用慢启动
- 当cwnd > ssthresh时，停止使用慢启动，改用拥塞避免
- 当cwnd = ssthresh时，可以使用慢启动，也可以使用拥塞避免



拥塞避免阶段，发送端拥塞窗口cwnd每经过一个往返时延RTT就增加一个MSS的大小，表现为线性增长

无论在哪个阶段，只要出现了超时，就将ssthresh设置为当前cwnd的一半，ssthresh阈值减半时向下取整，然后将cwnd设置为一，之后进入慢启动阶段



#### 快速恢复

当发送方连续收到3个冗余ACK的时候就进入快速恢复状态

1. 设置sshresh = cwnd / 2，cwnd = sshresh + 3
2. 重传丢失的数据包
3. 如果只收到Dup ACK，那么cwnd = cwnd + 1， 并且在允许的条件下发送一个报文段
4. 如果收到新的ACK, 设置cwnd = ssthresh， 进入拥塞避免阶段

# 四、网络层

1. 路由器的主要功能包括：路由选择（确定哪一条路径）与分组转发（当一个分组到达时所采用的动作）
2. 路由表是根据路由选择算法得出的，转发表示从路由表得出的。转发表的结构应当使查找过程最优化。路由表需要对网络拓扑变化的计算最优化。在讨论路由选择的原理时一般不做区分二者，笼统的使用路由表一词。
3. 根据路由算法是否能够自适应地进行调整变化来划分，可以分为**静态路由选择策略**和**动态路由选择策略**。动态路由选择策略可以分为**距离向量路由算法（DV）**和**链路状态路由算法（LS）**。

### 路由器结构

<img src="../../../E/typora/Pictures/image-20201227225133148.png" alt="image-20201227225133148" style="zoom: 20%;" />

路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因

### 距离向量算法（DV）

所有的结点都定期地将他们整个路由选择表传送给所有与之**直接相邻**的结点。这种路由选择表包含**每条路径的目的地**（另一结点）和**路径的代价**（距离）

更新路由选择表的情况：

- 被通知一条新的路由，该路由在本结点的路由表中不存在，此时本地结点加入这条新的路由
- 被通知一条新的路由，该路由比当前使用的路由有更小的距离（如RIP中是更小的跳数），用经过发送路由信息结点的新路由，替换路由表中达到目的结点的现路由。

最常用的DV算法是RIP（使用UDP）和BGP（使用TCP）

### 链路状态算法（LS）

每个参与算法的结点拥有完全的网络拓扑信息，使用Dijkstra算法计算达到所有网络结点各自的最短路径。

最常用的LS算法是OSPF（使用IP）

### 层次路由

因特网将整个互联网划分为许多较小的自治系统（一个自治系统不是一个局域网，里面包含很多局域网），原因如下：

- 因特网规模大，如果所有的路由器相连，路由器交换路由信息的带宽将使因特网的通信链路饱和
- 许多单位不愿外界了解本单位的网络的布局细节和路由选择协议，同时还希望连接上因特网

每个自治系统有权自主决定本系统内采用何种路由选择协议，即**内部网关协议（IGP）**，如RIP和OSPF

自治系统间使用的路由选择协议成为**外部网关协议（EGP）**，主要在不同自治系统的路由器之间交换路由信息，并负责为分组在不同自治系统之间选择最优的路径，具体的协议有BGP。

自治系统内部的路由选择成为域内路由选择，自治系统间的路由选择称为域间路由选择

#### OSPF区域划分

对于非常大的网络，OSPF协议将一个自治系统再划分为若干个更小的范围，称为**区域**。每个区域内部的路由器只知道本区域的完整拓扑。OSPF使用层次结构的区域划分。在上层的区域称为**骨干区域**。骨干区域作用是连通其他在下层的区域。从其他区域来的信息都由**区域边界路由器**进行概括。每个区域都至少有一个区域边界路由器。一个骨干区域路由器也可以是区域边界路由器。在骨干区域内还有一个路由器，专门与本自治系统外的其他自治系统交换路由信息，称为**自治系统边界路由器**。OSPF协议能够使每一个区域内部交换路由信息的通信量大大减少，使之能够用于大规模的自治系统中。

### IPv4

#### IP数据报结构

<img src="../../../E/typora/Pictures/image-20201227165050009.png" alt="image-20201227165050009" style="zoom: 18%;" />

版本：IPV4或IPV6

首部长度：4B为单位

区分服务：标记数据的类型

标识：2B，产生IP数据报的标识

标志：3位，只有前两位管用（位2和1）

- 位0：保留，必须为0；

- 位1：DF禁止分片（Don’t Fragment，DF），当DF=0时才允许分片；

  > 比如一个数据报经过某个路由器发其长度超过了最大发送长度，并且DF = 1，那么该数据报就过不去了，只能被路由器丢弃。如果DF=0，则仍然可以分片传送

- 位2：MF更多分片（More Fragment，MF），MF=1代表后面还有分片，MF=0 代表已经是最后一个分片。

片偏移：13位，以**8B**为单位（原因是总长度占16bit，而片偏移只占13bit）

<img src="../../../E/typora/Pictures/image-20201227171506049.png" alt="image-20201227171506049" style="zoom:18%;" />

具有**相同标识**的数据报片在目的站就可以正确地重装成原来的数据报了。

生存时间：（Time To Live）TTL，数据报可以在网络中通过路由器的最大值

协议：上层协议类型TCP、UDP等

首部校验和：**只校验首部，不检验数据**

IP数据报在传输过程中生存时间，标志，校验和部分可能变化。

#### IPv4地址

1. 实际上IP地址是标志一个主机（或路由器）和一条链路的接口。当一台主机同时连接到两个网络上时，该主机就必须同时拥有两个相应的IP地址，其网络号必须是不同的。例如，路由器的每个接口都有一个不同网络号的IP地址。路由器总是具有两个或两个以上IP地址。交换机互连的网络仍然是一个局域网，只能有一个网络号。

##### ip地址分类

<img src="../../../E/typora/Pictures/image-20201227191101790.png" alt="image-20201227191101790" style="zoom: 67%;" />

主机号全0表示该网络，全1表示广播地址。

A类地址地址范围：**0. 0. 0. 1－127.255.255.254**

> 网络地址全0的IP地址时保留地址，意思是本网络。如A类地址0.0.0.1表示在这个网络上主机号为1的主机
>
> 网络地址为01111111保留作为本地软件**环回测试**本主机的进程之间的通信
>
> 所以A类地址网络数为2^7^-2，而别的地址的网络数则不会因为上面两个原因减2

B类地址地址范围：**128.0.0.1－191.255.255.254**，实际上网络号128.0是不指派的，网络数为2^14^-1

C类地址地址范围：**192.0.0.1－223.255.255.254** ，实际上网络号192.0.0是不指派的，网络数为2^21^-1



私有地址：**10.x.x.x**,  **172.16.x.x-172.31.x.x**,  **192.168.x.x**  ，这三个地址段被称为私有IP地址段，也就是局域网所使用的地址段，在公网上不能被路由。

**0.0.0.0**：主要是用来标识不清楚的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到这个地址

**255.255.255.255**：这个地址是受限的广播地址。主要指一个网段内的所有主机



| 6类特殊地址          | 网络号 | 主机号       | 源地址或目的地址     |
| -------------------- | ------ | ------------ | -------------------- |
| 网络地址             | 特定的 | 全0          | 都不是               |
| 直接广播地址         | 特定的 | 全1          | 目的地址             |
| 受限广播地址         | 全1    | 全1          | 目的地址             |
| 这个网络上的这个主机 | 全0    | 全0          | 源地址或默认目的地址 |
| 这个网络上的特定主机 | 全0    | 特定的       | 目的地址             |
| 环回地址             | 127    | 不是全0或全1 | 源地址或目的地址     |

受限广播地址会被路由器阻拦，限于本地局域网内传播

使用环回地址时分组永远离不开这个机器

##### 子网划分

两级IP地址（网络号+主机号）不够灵活，于是加上了一个子网号字段使得IP地址变为三级的IP地址。**划分子网是一个单位内部的事情，单外对外仍然表现为没有划分子网的网络**。

划分子网的思路：从主机号借用若干个比特作为子网号，主机号就减少了若干比特，三级IP地址可记为：

```
IP地址：：={<网络号>，<子网号>，<主机号>}
```

凡是从其他网络发送给本单位某个主机的IP分组，仍然根据IP分组的目的网络号先找到连接在本单位网络上的路由器，然后此路由器在收到IP分组后，再按目的网络号和子网号找到目的的子网，最后将该IP分组直接交付给目的主机。

进行子网划分时，子网号不能为全0或1，但是CIDR可以，CIDR不能算是划分子网，只是形式上像划分子网，准确说应该是划分子块。

使用子网划分后，路由表的每行所包括的主要内容是【目的网络地址、子网掩码、下一跳地址】

<img src="../../../E/typora/Pictures/image-20201227223721012.png" alt="image-20201227223721012" style="zoom: 67%;" />

##### CIDR(Classless Inter-Domain Routing，CIDR)

使用无分类域间路由CIDR后，使用斜线记法，IP地址又从三级地址回到了两级地址：

```
IP地址：：={<网络前缀>，<主机号>}
```

使用CIDR时路由表可能会有多个匹配结果，应当选择具有最长网络前缀的路由。称为最长匹配或最佳匹配。

CIDR的掩码称之为**网络掩码**

### IP分片与TCP分段

**MTU（最大传输单元）**大家都知道，是链路层中的网络对数据帧的一个限制，依然以以太网为例，MTU为1500个字节。一个IP数据报在以太网中 传输，如果它的长度大于该MTU值，就要进行分片传输，使得每片数据报的长度小于MTU。分片传输的IP数据报不一定按序到达，但IP首部中的信息能让这些数据报片按序组装。IP数据报的分片与重组是在网络层进完成的。

  **MSS（最大分段大小）**是TCP里的一个概念（首部的选项字段中）。MSS是TCP数据包每次能够传输的最大数据分段，TCP报文段的长度大于MSS时，要进行分段传输。**TCP协议在建立连接的时候通常要协商双方的MSS值，每一方都有用于通告它期望接收的MSS选项（MSS选项只出现在SYN报文段中，即TCP三次握手的前两次）**。MSS的值一般为MTU值减去两个首部大小（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes）所以如果用链路层以太网，MSS的值往往为1460。而Internet上标准的MTU（最小的MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。TCP报文段的分段与重组是在运输层完成的。

  到了这里有一个问题自然就明了了，TCP分段的原因是MSS，IP分片的原因是MTU，由于一直有MSS<=MTU，很明显，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了。因此TCP报文段很少会发生IP分片的情况。

  再来看UDP数据报，由于UDP数据报不会自己进行分段，因此当长度超过了MTU时，会在网络层进行IP分片。同样，ICMP（在网络层中）同样会出现IP分片情况。

  总结：**UDP不会分段，就由IP来分。TCP会分段，当然就不用IP来分了！**

  **另外，IP数据报分片后，只有第一片带有UDP首部或ICMP首部，其余的分片只有IP头部，到了端点后根据IP头部中的信息再网络层进行重组。而TCP报文段的每个分段中都有TCP首部，到了端点后根据TCP首部的信息在传输层进行重组。IP数据报分片后，只有到达目的地后才进行重组，而不是像其他网络协议，在下一站就要进行重组。**

  **TCP分段仅发生在发送端，IP分片不仅会发生在在使用UDP、ICMP等没有分段功能的传输层协议的数据发送方，更还会发生在传输途中，甚至有可能都会发生，这是因为原本的大数据报被分片后很可能会经过不同MTU大小的链路。**

**在发送端**进行TCP分段后就一定不会在IP层进行分片，因为MSS本身就是基于MTU推导而来，TCP层分段满足了MSS限制，也就满足了MTU的物理限制。但在TCP分段发生后仍然可能发生IP分片，这是因为TCP分段仅满足了通信两端的MTU要求，传输路径上如经过MTU值比该MTU值更小的链路，那么在转发分片到该条链路的设备中仍会以更小的MTU值作为依据再次分片。当然如果两个通信主机直连，那么TCP连接协商得到的MTU值(两者网卡MTU较小值)就是端到端的路径MTU值，故发送端只要做了TCP分段，则在整个通信过程中一定不会发生IP分片。

### NAT

执行NAT，路由器必须做到:

- 外出的分组: 替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT IP 地址, 新端口号) 

- 远程客户/服务器用(NAT IP地址, 新端口号)作为目的地来响应。

- (在NAT转换表中)记录每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 转换配对

- 进来的分组: 对每个进来的分组，用保存在NAT表中的对应的(源IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号）

### ARP协议

当源主机欲向本局域网上某个目标主机发送IP分组时，应先在其ARP高速缓存中查看有无目标主机的IP地址。如果有，则可以查出其对应的硬件地址，再将此硬件地址写入MAC帧，然后通过局域网将该MAC帧发往此硬件地址。如果没有，则先通过广播ARP请求分组，在获得目标主机的ARP响应分组后，将目标主机的硬件地址写入ARP高速缓存，建立起目标主机IP到硬件地址的映射。

如果发送方和接收方在同一局域网，那么就是接收方向发送方发送ARP响应分组。如果不在同一局域网，那就必须由一个连接在本发送方局域网的路由器转发ARP请求分组。这时，该路由器向发送方发送ARP回答分组，给出自己的硬件地址。

### DHCP

2DHCP协议是一个四步骤的过程：DHCP服务器发现（DHCPDISCOVER）（客户端口号68，服务器端口号67），DHCP服务器提供（DHCPOFFER），DHCP请求（DHCPREQUEST），DHCP ACK（DHCPACK）。全程目的ip地址均为255.255.255.255，客户源ip地址为0.0.0.0，服务器ip地址为其ip地址。

 DHCP 客户可随时提前终止服务器所提供的租用期，这时只需向 DHCP 服务器发送释放报文 DHCPRELEASE 即可。

>  DHCP 客户现在要根据服务器提供的租用期 T 设置两个计时器 T1 和 T2，它们的超时时间分别是 0.5T 和 0.875T。当超时时间到就要请求更新租用期。租用期过了一半（T1 时间到），DHCP 发送请求报文 DHCPREQUEST 要求更新租用期。DHCP 服务器若不同意，则发回否认报文DHCPNACK。这时 DHCP 客户必须立即停止使用原来的 IP 地址，而必须重新申请 IP 地址。DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP 客户得到了新的租用期，重新设置计时器。若DHCP服务器不响应请求报文DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST。

 DHCP分配的不仅仅是IP地址，还可分配：客户的第一跳路由器的地址（默认网关），DNS服务器的IP地址或域名，子网掩码

### ICMP

<img src="../../../E/typora/Pictures/image-20201227224425497.png" alt="image-20201227224425497" style="zoom: 67%;" />

<img src="../../../E/typora/Pictures/image-20201227224440098.png" alt="image-20201227224440098" style="zoom:50%;" />

<img src="../../../E/typora/Pictures/image-20201227224652595.png" alt="image-20201227224652595" style="zoom: 67%;" />

# 附录一、面试问题

## 如何排查网络问题

1. 网卡是否正常工作: ifconfig ethN

2. 是否正确设置网关: route -n（显示路由表）和 ping配合使用（ping网关看看网关是否可以连通）

3. 查看DNS工作情况 nslookup

4. 是否可以连接到远程主机：traceroute

5. 对方主机是否开放端口：telnet nmap

6. 本机查看监听端口netstat -lnp | grep :PORT

   > -a (all)显示所有选项，默认不显示LISTEN相关
   > -t (tcp)仅显示tcp相关选项
   > -u (udp)仅显示udp相关选项
   > -n 拒绝显示别名，能显示数字的全部转化成数字。
   > -l 仅列出有在 Listen (监听) 的服务状态
   >
   > -p 显示建立相关链接的程序名
   > -r 显示路由信息，路由表
   > -e 显示扩展信息，例如uid等
   > -s 按各个协议进行统计
   > -c 每隔一个固定时间，执行该netstat命令。

7. 查看防火墙规则 iptables -L


# 操作系统

[TOC]

# 【1】 linux下的多线程/多进程同步/通信机制

> 参考资料：https://blog.csdn.net/KingCat666/article/details/75269593

关于标准接口，Linux系统中提供了POSIX和 System V这两种不同的接口，POSIX为可移植的操作系统接口。System V 是 AT&T 的第一个商业UNIX版本(UNIX System III)的加强。System V 时期的不同系统接口不一样，给移植带来了一定的麻烦，而**POSIX将不同操作系统之间的上层API进行了统一**，更换平台时**便于移植应用程序**。目前Linux中使用POSIX较多，但System V同样也存在。

linux下进程间通信的几种主要**手段**：    

1. **管道（Pipe）及有名管道（named pipe）**：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；  

2. **报文（Message）队列（消息队列）**：消息队列是消息的链接表，包括Posix消息队列system V消息队列。**消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。而且，每个数据块被认为含有一个类型，接收进程可以独立地接收含有不同类型值的数据块**。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。与命名管道相比：消息队列的优势在于，它**独立于发送和接收进程而存在**，这消除了在同步命名管道的打开和关闭时可能产生的一些困难。

   优点：

      A. 我们可以通过发送消息来几乎完全避免命名管道的同步和阻塞问题。

      B. 我们可以用一些方法来提前查看紧急消息。

   缺点：

      A. 与管道一样，每个数据块有一个最大长度的限制。

      B. 系统中所有队列所包含的全部数据块的总长度也有一个上限。

3. **信号（Signal）**：信号是比较复杂的通信方式，用于通知接受进程有某种事件生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期 信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上， 该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，sigaction函数重新实现了signal函数）；    

4. **信号量（semaphore）**：主要作为进程间以及同一进程不同线程之间的同步手段。     

5. **共享内存**：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针其他通信机制运行效率较低设计的。**共享内存没有提供同步的机制**，往往与其它通信机制，如信号量结合使用， 来达到进程间的同步及互斥。由于内存实体存在于计算机系统中．所以只能由处于同一个计算机系统中的诸进程共享。不方便网络通信。   

6. **套接字（Socket）**：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix 系统上：Linux和System V的变种都支持套接字。



用于**进程间通信(IPC Inter-Process Communication)**的四种不同技术: 

1. **消息传递**(PIPE,FIFO,posix和system v消息队列) 

2. **同步**(**互斥锁**,**条件变量**,**读写锁**,**文件和记录锁**,Posix和System V**信号灯**) 

3. **共享内存区**(匿名共享内存区,有名Posix共享内存区,有名System V共享内存区) 

4. **过程调用**(Solaris门,Sun RPC) 

**消息队列**和**过程调用**往往单独使用,也就是说它们通常提供了自己的同步机制.相反,**共享内存区**通常需要由应用程序提供的某种同步形式才能正常工作.解决某个特定问题应使用哪种IPC不存在简单的判定,应该逐渐熟悉各种IPC形式提供的机制,然后根据特定应用的要求比较它们的特性。

## 管道

> 参考资料：https://zhuanlan.zhihu.com/p/58489873

### 什么是管道

目前在任何一个shell中，都可以使用“|”连接两个命令，shell会将前后两个进程的输入输出用一个管道相连，以便达到进程间通信的目的：

```shell
[zorro@zorro-pc pipe]$ ls -l /etc/ | wc -l
183
```

可以理解为，**管道本质上就是一个文件，前面的进程以写方式打开文件，后面的进程以读方式打开**。这样前面写完后面读，于是就实现了通信。

虽然实现形态上是文件，但是管道本身并不占用磁盘或者其他外部存储的空间。在Linux的实现上，它**占用的是内存空间**。所以，**Linux上的管道就是一个操作方式为文件的内存缓冲区**。

### 管道的分类和使用

Linux上的管道分两种类型：

1. 匿名管道
2. 命名管道

#### 匿名管道

匿名管道最常见的形态就是我们在shell操作中最常用的”|”。它的特点是**只能在父子进程中使用**，父进程在产生子进程前必须打开一个管道文件，然后fork产生子进程，这样子进程通过拷贝父进程的进程地址空间**获得同一个管道文件的描述符**，以达到使用同一个管道通信的目的。此时除了父子进程外，没人知道这个管道文件的描述符，所以通过这个管道中的信息无法传递给其他进程。这保证了传输数据的安全性，当然也降低了管道了通用性，于是系统还提供了命名管道。

#### 命名管道

我们可以使用`mkfifo`或`mknod`命令来创建一个命名管道，这跟创建一个文件没有什么区别：

```shell
[zorro@zorro-pc pipe]$ mkfifo pipe
[zorro@zorro-pc pipe]$ ls -l pipe 
prw-r--r-- 1 zorro zorro 0 Jul 14 10:44 pipe
```

可以看到创建出来的文件类型比较特殊，是p类型。表示这是一个管道文件。有了这个管道文件，系统中就有了对一个管道的全局名称，于是任何两个不相关的进程都可以通过这个管道文件进行通信了。

可以看到创建出来的文件类型比较特殊，是p类型。表示这是一个管道文件。有了这个管道文件，系统中就有了对一个管道的全局名称，于是任何两个不相关的进程都可以通过这个管道文件进行通信了。比如我们现在让一个进程写这个管道文件：

```shell
[zorro@zorro-pc pipe]$ echo xxxxxxxxxxxxxx > pipe 
```

此时这个写操作会**阻塞**，因为管道另一端没有人读。这是内核对管道文件定义的默认行为。此时如果有进程读这个管道，那么这个写操作的阻塞才会解除：

```shell
[zorro@zorro-pc pipe]$ cat pipe 
xxxxxxxxxxxxxx
```

可以观察到，当我们cat完这个文件之后，另一端的echo命令也返回了。这就是命名管道。

我们可以把匿名管道和命名管道分别叫做**PIPE**和**FIFO**。这主要因为在系统编程中，创建匿名管道的系统调用是pipe()，而创建命名管道的函数是mkfifo()。

管道实际上可以实现一个半双工通信的机制。使用同一个管道的父子进程可以**分时**给对方发送消息。

<img src="../../../E/typora/Pictures/v2-2abd242aba9a348bff654a23e640522c_720w.png" alt="img" style="zoom:67%;" />

但是管道推荐的使用方法是其单工模式：即只有两个进程通信，一个进程只写管道，另一个进程只读管道。

<img src="../../../E/typora/Pictures/v2-af14e889e3ca398671e4f4940cd779a6_720w.png" alt="img" style="zoom:67%;" />

## 管道和消息队列的对比

1. PIPE和FIFO是**字节流**，没有**消息边界**。Posix消息队列和System V消息队列则有从发送者向接受者维护的**记录边界**
2. 当有一个消息放置到一个空队列中时,Posix消息队列可向一个进程发送一个信号,或者启动一个新的线程.System V则不提供类似的通知形式. 
3. 管道和FIFO的数据字节是先进先出的。Posix消息和System V消息具有由发送者赋予的优先级.从一个Posix消息队列读出时,首先返回的总是优先级最高的消息.从一个System V消息队列读出时,读出者可以要求想要的任意优先级的消息. 

## 信号量

> 参考资料：https://www.jianshu.com/p/6e72ff770244

信号量是包含一个**非负整数型的变量**，表示可用资源的数量，并且带有两个原子操作`wait`和`signal`。Wait还可以被称为down、P或lock，signal还可以被称为up、V、unlock或post。在UNIX的API中（POSIX标准）用的是`wait`和`post`。

对于wait操作，如果信号量的非负整形变量S大于0，wait就将其减1，如果S等于0，wait就将调用线程阻塞；对于post操作，如果有线程在信号量上阻塞（此时S等于0），post就会解除对某个等待线程的阻塞，使其从wait中返回，如果没有线程阻塞在信号量上，post就将S加1.

POSIX信号量是一个`sem_t`类型的变量，但POSIX有两种信号量的实现机制：**无名信号量**和**命名信号量**。无名信号量只可以在**共享内存**的情况下，比如实现进程中各个线程之间的互斥和同步，因此无名信号量也被称作基于内存的信号量；命名信号量通常用于**不共享内存的情况下**，比如进程间通信。

同时，在创建信号量时，根据信号量取值的不同，POSIX信号量还可以分为：

- **二值型信号量**：信号量的值只有0和1，这和互斥量很类似，若资源被锁住，信号量的值为0，若资源可用，则信号量的值为1；
- **计数型信号量**：信号量的值在0到一个大于1的限制值之间，该计数表示可用的资源的个数。

POSIX信号量接口：

<img src="../../../E/typora/Pictures/14085063-ae9b5fea6b4f9af1" alt="img" style="zoom: 67%;" />

### 命名和无名信号量的持续性

命名信号量是随内核持续的。当命名信号量创建后，即使当前没有进程打开某个信号量，它的值依然保持，直到内核重新自举或调用sem_unlink()删除该信号量。

无名信号量的持续性要根据信号量在内存中的位置确定：

- 如果无名信号量是在单个进程内部的数据空间中，即信号量只能在进程内部的各个线程间共享，那么信号量是随进程的持续性，当进程终止时他也就消失了；

如果无名信号量位于不同进程的共享内存区，因此只要该共享内存区仍然存在，该信号量就会一直存在；所以此时无名信号量是随内核的持续性。

# 【2】线程同步机制

> 参考资料：https://blog.csdn.net/KingCat666/article/details/75269593

线程的最大特点是资源的共享性，linux下提供了多种方式来处理线程同步，最常用的是**互斥锁**、**条件变量**和**信号量**（实现在上面进程同步有讲）。还有屏障和自旋锁（与互斥锁一样，但是阻塞后不会让出cpu，会一直忙等待，直到得到锁）

## 互斥锁

1. 初始化锁

   在Linux下，线程的互斥量数据类型是pthread_mutex_t。在使用前,要对它进行初始化。

   ```c
   静态分配：pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
    
   动态分配：int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutex_attr_t *mutexattr);
   ```

2. 加锁

   对共享资源的访问，要对互斥量进行加锁，如果互斥量已经上了锁，调用线程会阻塞，直到互斥量被解锁。

   ```c
   int pthread_mutex_lock(pthread_mutex *mutex); // 阻塞型
    
   int pthread_mutex_trylock(pthread_mutex_t *mutex); // 非阻塞型
   ```

3. 解锁。在完成了对共享资源的访问后，要对互斥量进行解锁。

   ```c
   int pthread_mutex_unlock(pthread_mutex_t *mutex);
   ```

4. 销毁锁。锁在是使用完成后，需要进行销毁以释放资源。

   ```c
   int pthread_mutex_destroy(pthread_mutex *mutex);
   ```

## 条件变量（cond）

条件变量是为了**等待**而不是上锁而设计的，条件变量用来自动阻塞一个线程，直到某**特殊情况发生为止**。通常条件变量和互斥锁同时使用。

主要包括两个动作：一个线程等待"条件变量的条件成立"而阻塞；另一个线程使"条件成立"（给出条件成立信号）。

**条件**的检测是在**互斥锁**的保护下进行的。如果一个条件为假，一个线程自动阻塞，并**释放等待状态改变的互斥锁**。如果另一个线程改变了条件，它**发信号**给关联的条件变量，唤醒一个或多个等待它的线程，重新获得互斥锁，重新评价条件。如果两进程共享可读写的内存，条件变量可以被用来实现这两进程间的线程同步。

相关的函数如下：

```c
1 int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr);     
2 int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex);
3 int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime);
4 int pthread_cond_destroy(pthread_cond_t *cond);  
5 int pthread_cond_signal(pthread_cond_t *cond);
6 int pthread_cond_broadcast(pthread_cond_t *cond);  //解除所有线程的阻塞
```

## 屏障（barrier）

barrier(屏障)与互斥量，读写锁不同，它不是用来保护临界区的。相反，它跟条件变量一样，是用来协同多线程一起工作！！！

条件变量是多线程间传递状态的改变来达到协同工作的效果。屏障是多线程各自做自己的工作，如果某一线程完成了工作，就等待在屏障那里，**直到其他线程的工作都完成了，再一起做别的事**。

# 【3】linux下的wait、waitpid、wait3、wait4函数

> 参考资料：https://www.cnblogs.com/tongye/p/9558320.html

## wait函数

函数原型

```c
#include <sys/types.h>        // 提供类型 pid_t 的定义
#include <sys/wait.h>

pid_t wait(int *status);
```

wait()函数用于使父进程（也就是调用wait()的进程）阻塞，直到一个子进程结束或者该进程接收到了一个指定的信号为止。如果该父进程没有子进程或者它的子进程已经结束，则wait()函数就会立即返回。

参数 status 保存着子进程退出时的一些状态（包括 task_struct、thread_info及内核栈等）

## waitpid函数

waitpid()的作用和wait()一样，但它**并不一定要等待第一个终止的子进程**（它可以指定需要等待终止的子进程），它还有**若干选项**，如可提供一个非阻塞版本的 wait()功能，也能支持作业控制。实际上，wait()函数只是 waitpid()函数的一个特例，在Linux 内部实现 wait()函数时直接调用的就是waitpid()函数。

函数原型：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid,int *status,int options);
```

pid < -1 ；等待进程组 ID 为 pid 绝对值的进程组中的任何子进程；

pid = -1 ；等待任何子进程，此时 waitpid() 相当于 wait()。**实际上，wait()就是 pid = -1、options = 0 的waitpid()，** 且有：

```
static inline pid_t wait(*status){
    return waitpid(-1,*status,0);  
}
```

pid = 0 ；等待进程组 ID 与当前进程相同的任何子进程（也就是等待同一个进程组中的任何子进程）；

pid > 0 ；等待任何子进程 ID 为 pid 的子进程，只要指定的子进程还没有结束，waitpid() 就会一直等下去。



参数 options提供一些额外的选项来控制 waitpid()

## wait3和wait4函数

函数原型：

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait3(int *status,int options,struct rusage *rusage);
pid_t wait4(pid_t pid,int *status,int options,struct rusage *rusage);
```

wait3() 和 wait4() 函数除了可以获得**子进程状态信息**外，还可以获得**子进程的资源使用信息**，这些信息是通过参数 rusage 得到的。而 wait3() 与 wait4() 之间的区别是，wait3() 等待所有进程，而 wait4() 可以根据 pid 的值选择要等待的子进程，参数 pid 的意义与 waitpid() 函数的一样。

# 【4】linux创建线程

```c
#include <pthread.h>

int pthread_create(pthread_t *restrict tidp,
                   const pthread_attr_t *restrict attr,
                   void *(*start_rtn)(void), 
                   void *restrict arg);
```

C99 中新增加了 restrict 修饰的指针： 由 restrict 修饰的指针是最初唯一对指针所指向的对象进行存取的方法，仅当第二个指针基于第一个时，才能对对象进行存取。

第一个参数为指向线程标识符的指针。

第二个参数用来设置线程属性。

第三个参数是线程运行函数的起始地址。

第四个参数是运行函数的参数。

# 【5】 进程

# 【6】mmap

> 参考资料：https://www.cnblogs.com/huxiao-tee/p/4660352.html

mmap是一种内存映射文件的方法，即将一个**文件**或者其它对象**映射到进程的地址空间**，实现**文件磁盘地址**和**进程虚拟地址空间**中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以**采用指针的方式读写**操作这一段内存，而**系统会自动回写脏页面到对应的文件磁盘上**，即完成了对文件的操作而**不必再调用**read,write等**系统调用函数**。相反，**内核空间对这段区域的修改也直接反映用户空间**，从而可以实现不同进程间的文件共享。

mmap映射区域大小必须是物理页大小(page_size)的整倍数（32位系统中通常是4k字节）。原因是内存的最小粒度是页.

<img src="../../../E/typora/Pictures/200501092691998.png" alt="img" style="zoom:80%;" />

**常规读文件过程**

1、进程发起读文件请求。

2、内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的inode。

3、inode在address_space上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。

4、如果不存在，则通过inode定位到文件磁盘地址，将数据从磁盘**复制到页缓存**。之后再次发起读页面过程，进而**将页缓存中的数据发给用户进程**。



常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将页缓存中数据页再次拷贝到内存对应的用户空间中。



**mmap读文件过程**

**创建新的虚拟内存区域**和**建立文件磁盘地址和虚拟内存区域映射**这两步，没有任何文件拷贝操作。而之后访问数据时发现内存中并无数据而发起的缺页异常过程，可以通过已经建立好的映射关系，只使用一次数据拷贝，就从磁盘中将数据传入内存的用户空间中，供进程使用。



**总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而mmap操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。**



## mmap的优点

1、对文件的读取操作跨过了页缓存，**减少了数据的拷贝次数**，用内存读写取代I/O读写，提高了文件读取效率。

2、**实现了用户空间和内核空间的高效交互方式**。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。

3、**提供进程间共享内存及相互通信的方式**。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。

   同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。

## mmap相关函数

```c++
void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);
```

start：映射区的开始地址

length：映射区的长度

prot：期望的内存保护标志，不能与文件的打开模式冲突。是以下的某个值，可以通过or运算合理地组合在一起

flags：指定映射对象的类型，映射选项和映射页是否可以共享。它的值可以是一个或者多个以下位的组合体

fd：有效的文件描述词。如果MAP_ANONYMOUS被设定，为了兼容问题，其值应为-1

offset：被映射对象内容的起点

```c++
int msync( void *addr, size_t len, int flags )
```

可以通过调用msync()实现磁盘上文件内容与共享内存区的内容一致。